"""题目描述"""
'''
给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：
操作 1 ：如果二进制串包含子字符串 "00" ，你可以用 "10" 将其替换。
比方说， "00010" -> "10010"
操作 2 ：如果二进制串包含子字符串 "10" ，你可以用 "01" 将其替换。
比方说， "00010" -> "00001"
请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。
'''

"""示例"""
'''
输入：binary = "000110"
输出："111011"
解释：一个可行的转换为：
"000110" -> "000101" 
"000101" -> "100101" 
"100101" -> "110101" 
"110101" -> "110011" 
"110011" -> "111011"
'''

"""解题思路"""
'''
v1.0:
- 思路就是大彻大悟，按照规则，所有的0都是可以往前面前进然后变成1的，然后发现结果至多存在一个0
- 所以解答的思路就是找寻0的位置处在哪里使得这个数最大了，也就是说不要改变初始的状态，使0全部排列在一起
- 举个例子：`0101110` 变成 `0001111` 然后你会发现结果是`1101111` 0在`[3-1]`的位置，3是什么，是0的数量。
- 然而这还不够，这是因为0在首位，如果不在首位呢：`1001110`变成`1000111`结果`1110111`。
        所以起始位置就是0最先出现的位置，代码中用`index`表示。
'''


class Solution:
    def maximumBinaryString(self, binary: str) -> str:
        n = len(binary)
        if n == 1:
            pass
        blist = list(binary)
        if "0" in blist:
            index = blist.index("0")
            addindex = blist.count("0")
            res=["1"]*n
            res[index + addindex -1]="0"
            r = ''.join(res)
            return r
        else:
            return binary